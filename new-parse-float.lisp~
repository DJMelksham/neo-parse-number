(defun parse-float (string &optional (value-on-error *default-value-on-error*))
  "Parse a string as a float if we deem it reasonably possible to do so."
  (handler-case 
      (let ((string-length (length string)) ;length of string to terminate early if done
	    (whole-part 0) ;stores the whole-number part of the float
	    (whole-length 0) ;keeps track of how many digits are in the whole-number part
	    (length-marker 0) ;keeps track of where we are in the string while parsing
	    (fraction-part 0) ;keeps track of the fraction part of the float
	    (fraction-length 0) ;keeps track of how many digits are in the fraction part
	    (exponent-value 0) ;stores the exponent of the float
	    (exponent-length 0) ;keeps track of how many digits are in the exponent
	    (exponent-base 10.0d0) ;base
	    (type-of-float 'DOUBLE-FLOAT)
	    (divisor 0)
	    (coercion-coefficient 1.0d0))

	;; First, we attempt to parse an integer from the left-most part of the string
	;; storing the value and the length of the parsed integer in the respective
	;; values and incrementing our place in the full string
	;; This constitutes the whole part of the floating point number

	(multiple-value-setq (whole-part whole-length) (parse-integer string :junk-allowed t))
	(incf length-marker whole-length) ;;increment relative position by length of first int

	;; If our previous operation didn't parse the entire string in one go,
	;; we increment our relative position in the string by 1 (within the subseq)
	;; in order to avoid the period in a floating point representation
	;; and parse a second integer from that point on.
	;; This consistutes the fractional part of the floating point number
	
	(if (not (eql string-length length-marker))
	    (progn
	      (multiple-value-setq (fraction-part fraction-length)
		(parse-integer (subseq string (incf length-marker)) :junk-allowed t))
	      (incf length-marker fraction-length)))

	;; If our previous operation didn't parse the entire string yet,
	;; we now deal with identifying exponent markers
	;; if none are present, or if the ambiguous
	;; character of #\e or #\E is present, we use a default
	;; value (by convention, a double float)
	;; We coerce the other numbers we use in our final calculation
	;; to the same type
	
	(if (not (eql length-marker string-length))
	    (progn
	      (setf coercion-coefficient (case (char string length-marker)
					   ((#\d #\D) 1.0d0)
					   ((#\e #\E) (coerce coercion-coefficient *default-float-format*))
					   ((#\f #\F) 1.0f0)
					   ((#\s #\S) 1.0s0)
					   ((#\l #\L) 1.0l0)
					   (t (coerce coercion-coefficient *default-float-format*)))
		    
		    type-of-float (type-of coercion-coefficient)
		    
		    exponent-base (coerce exponent-base (type-of coercion-coefficient)))
	      
	      (multiple-value-setq (exponent-value exponent-length) (parse-integer (subseq string (incf length-marker)) :junk-allowed t))
	      (incf length-marker exponent-length)))

	;; Now we built up the final float
	;; Note how we have to check whether it is a positive or negative float
	;; because adding a positive fractional-part to negative whole-part
	;; moves the representation in the wrong direction

	(coerce (print (* (+ (print (* (print whole-part) (expt 10 fraction-length)))
			     (print (if (minusp whole-part)
						(* fraction-part -1)
						fraction-part)))
			  (print (expt 10 (- exponent-value fraction-length)))))
		type-of-float))
    
    (error () value-on-error)))
